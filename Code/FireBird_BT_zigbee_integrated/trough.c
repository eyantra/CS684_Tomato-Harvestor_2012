#include<avr/io.h>
#include<avr/interrupt.h>
#include<util/delay.h>

volatile int ShaftCountRight=0;
volatile int ShaftCountLeft=0;

ISR(INT5_vect)
{
	ShaftCountRight++;
}

ISR(INT4_vect)
{
	ShaftCountLeft++;
}

void interrupt_left_init()
{
	DDRE = DDRE & 0xEF;
	PORTE = PORTE | 0x10;
}

void interrupt_right_init()
{
	DDRE = DDRE & 0xDF;
	PORTE = PORTE | 0x20;
}

void left_position_encoder_init(void)
{
	cli();
	EICRB=EICRB | 0x02;
	EIMSK=EIMSK |0x10;
	sei();
}

void right_position_encoder_init(void)
{
	cli();
	EICRB=EICRB | 0x08;
	EIMSK=EIMSK |0x20;
	sei();
}

void distance_move(int distance,int follow)		// Function that makes robot move by specified distance
{												// using interrupts generated by position encoder
	ShaftCountRight=0;							// If follow = 1, black line following is enabled, otherwise disabled. 
	int ShaftReq =(int)((float)distance/(5.44));// Division by resolution to get shaft count 
	while(1)
	{
		if(ShaftCountRight >= ShaftReq)
		{
			stop();								//Stop moving when required shaft count is obtained 
			break;
		}
		
		if(follow)
			move_bot();
		else
			forward();
	}
}


void angle_rotate(unsigned int Degrees)			//Function that makes robot rotate by specified number of degrees
{ 
 ShaftCountRight=ShaftCountLeft=0;
 float ReqdShaftCount = 0; 
 unsigned long int ReqdShaftCountInt = 0; 
 
 ReqdShaftCount = (float) Degrees/4.090;		//Division by resolution to get shaft count 
 ReqdShaftCountInt = (unsigned int) ReqdShaftCount; 

 while (1) 
 { 
  if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt)) 
  {
  	break;
  }
 }
 stop();										//Stop rotating when required shaft count is obtained 
}



int moveToTrough(int tno)						//Function that makes robot to move to trough specified
{
	//Distance from initial bot position to first trough = 25 cm
	//Length of the trough = 80 cm
	//Distance between two adjacent troughs = 5 cm
	//Distance between opposite troughs = 6.5 cm ( 4 + 2 + 0.5 )
	
	switch(tno)
	{
		case 1:
				distance_move((25)*10,1);			
				return 0;

		case 2:
				distance_move((25+80+5)*10,1);
				return 0;

		case 3:
				distance_move((25+80+5+80)*10,1);		// Move till end of the first aisle,
				right();								// Shift to third black line
				angle_rotate(90);
				distance_move((4+2+0.5)*10,0);
				right();
				angle_rotate(60);
				return 0;

		case 4:
				distance_move((25+80+5+80)*10,1);		// Move till end of the first aisle,
				right();								// Shift to third black line
				angle_rotate(90);						
				distance_move((4+2+0.5)*10,0);
				right();
				angle_rotate(60);

				distance_move((80+5)*10,1);	);			// Reach fourth trough
				return 0;
					
		case 5:
				distance_move((25+80+5+80)*10,1);		// Move till end of the first aisle,
				right();								// Shift to third black line
				angle_rotate(90);
				distance_move((4+2+0.5)*10,0);
				right();
				angle_rotate(60);

				distance_move((80+5+80+6)*10,1);		// Move till end of the second aisle,
				left();									// Reach third aisle
				angle_rotate(90);
				distance_move((25+12.5+25+13)*10,1);
				left();						
				angle_rotate(90);
				return 0;
				
		case 6:
				distance_move((25+80+5+80)*10,1);		// Move till end of the first aisle,
				right();								// Shift to third black line
				angle_rotate(90);
				distance_move((4+2+0.5)*10,0);
				right();
				angle_rotate(60);

				distance_move((80+5+80+6)*10,1);		// Move till end of the second aisle,
				left();									// Reach third aisle
				angle_rotate(90);
				distance_move((25+12.5+25+13)*10,1);
				left();						
				angle_rotate(90);

				distance_move((80+5+13)*10,1);			// Reach 6th trough 						
				return 0;
				
		case 7:
				distance_move((25+80+5+80)*10,1);		// Move till end of the first aisle,
				right();								// Shift to third black line
				angle_rotate(90);
				distance_move((4+2+0.5)*10,0);
				right();
				angle_rotate(60);

				distance_move((80+5+80+6)*10,1);		// Move till end of the second aisle,
				left();									// Reach third aisle
				angle_rotate(90);
				distance_move((25+12.5+25+13)*10,1);
				left();						
				angle_rotate(90);

				distance_move((80+5+80+13)*10,1);		// Move till end of the third aisle,
				right();								// Shift to third black line					
				angle_rotate(90);
				distance_move((4+2+0.5)*10,0);
				right();
				angle_rotate(60);						// Reach seventh trough
				return 0;

		case 8:
				distance_move((25+80+5+80)*10,1);		// Move till end of the first aisle,
				right();								// Shift to third black line
				angle_rotate(90);
				distance_move((4+2+0.5)*10,0);
				right();
				angle_rotate(60);

				distance_move((80+5+80+6)*10,1);		// Move till end of the second aisle,
				left(); 								// Reach third aisle
				angle_rotate(90);
				distance_move((25+12.5+25+13)*10,1);
				left();						
				angle_rotate(90);

				distance_move((80+5+80+13)*10,1);		// Move till end of the third aisle,
				right();								// Shift to third black line						
				angle_rotate(90);
				distance_move((4+2+0.5)*10,0);
				right();
				angle_rotate(60);

				distance_move((80+5)*10,1);				// Reach eighth trough						
				return 0;

		default:
				return 1;
	}
}

void returnToInitial(int tno)				//Function that makes bot to return to its initial position
{
	switch(tno)
	{
		//For the troughs that are in 1st and 3rd aisles, robot should turn backwards and move until it detects junction
		case 1:
		case 2:
		case 5:
		case 6:
				right();
				angle_rotate(180);
				while(1)
				{
					if(move_bot())
					break;
				}
				break;
		
		//For the troughs that are in 2nd and 4th aisles, robot should just move forward until it detects junction		
		case 3:				
		case 4:
		case 7:
		case 8:
				while(1)
				{
					if(move_bot())
					break;
				}
				break;
	}
	
	switch(tno)
	{
		//For the troughs that are in 3rd and 4th aisles, robot should turn right by 90 degrees and move forward
		//to reach initial position
		case 5:
		case 6:
				right();
				angle_rotate(90);
				distance_move((25+12.5+25+13)*10,1);
				left();
				angle_rotate(90);
				break;
				
		case 7:
		case 8:
				right();
				angle_rotate(90);
				distance_move((25+12.5+25+13+16)*10,1);
				left();
				angle_rotate(90);
				break;
	}
}
